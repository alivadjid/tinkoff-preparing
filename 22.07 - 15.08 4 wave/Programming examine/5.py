"""
Дедовский способ

Поговаривают, что олдскульные программисты до сих пор развлекаются с помощью стандартных игр наподобие сапера и пасьянса.

Общий смысл игры в пасьянс довольно прост - необходимо разложить карты в стопки по определенным правилам (например, по масти, по старшинству и т.п.).

Рассмотрим упрощенную версию игры, в которой участвуют N стопок карт, причем каждая карта имеет номинал от 1 до N. Целью нашей версии пасьянса будет разложить карты по стопкам так, чтобы карты с номиналом 1 находились в первой стопке, с номиналом 2 - во второй и так далее. При этом разрешается брать карту только с вершины колоды и класть только на вершину любой другой колоды.

Выпишите последовательность действий, которая позволит победить в игре.
Формат входных данных

В первой строке входных данных записано одно натуральное число N, не превосходящее 500. В следующих N строках описаны колоды карт: сначала записано число ﻿kiki​﻿ -- количество карт в колоде, а затем ﻿kiki​﻿ чисел -- номиналы карт в данной колоде, снизу вверх. В каждой колоде вначале не более 500 карт (в процессе игры это ограничение может быть нарушено).
Формат выходных данных

Программа должна вывести описание действий: для каждого действия напечатать два числа -- из какой колоды брать карту и в какую колоду класть. Если расстановка не имеет решения, необходимо вывести одно число 0.

Если решений несколько, выведите любое из них.
"""


from collections import deque

def solve(n, stacks):
    queue = deque([(stacks, [])])
    visited = set()

    while queue:
        state, actions = queue.popleft()
        if tuple(state) in visited:
            continue
        visited.add(tuple(state))

        if is_goal(state):
            return actions

        for i in range(n):
            for j in range(n):
                if i != j and state[i]:
                    new_state = [list(stack) for stack in state]
                    new_state[j].append(new_state[i].pop())
                    queue.append((new_state, actions + [(i, j)]))

    return 0

def is_goal(state):
    for i, stack in enumerate(state):
        if stack and stack[-1] != i + 1:
            return False
    return True

n = int(input())
stacks = [list(map(int, input().split()))[1:] for _ in range(n)]

result = solve(n, stacks)
if result == 0:
    print(0)
else:
    for action in result:
        print(action[0] + 1, action[1] + 1)